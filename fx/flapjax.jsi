// TODO: mutually recursive named contracts (all vars on top)
// method contracts that place conditions on this (for switch_e)
// EventStream-of (how generically???)
// arbitrary-length array contracts [ ctc, ... ]
// Behavior contract is either a higher-order behavior or a flat (constant) 
// value
// remove cond_e it is stupid
// DOM contract list
// dictionary contract (on $O)
// Stop exporting generic functions
{
  
function isHtml(x) {
  return x instanceof window.HTMLElement || x instanceof window.Text ||
    x instanceof window.Document;
};

// contract constructor.  Assumes ctc1 if the value satisfies ctc1.flat.
// Otherwise, assumes ctc2.  The server and client projections perform this
// test independently, so it's possible for a malformed inner contract to
// make one projection assume ctc1 and the other assume ctc2.
var or = function(name) { return function(ctc1, ctc2) {
  return {
    flat: function(val) {
      return ctc1.flat(val) || ctc2.flat(val);
    },
    server: function(s,loc) { return function(val) {
      if (ctc1.flat(val)) {
        return ctc1.server(s,loc)(val);
      }
      else {
        return ctc2.server(s,loc)(val);
      }
    } },
    client: function(s,loc) { return function(val) {
      if (ctc1.flat(val)) {
        return ctc1.client(s,loc)(val);
      }
      else {
        return ctc2.client(s,loc)(val);
      }
    } }
  }; 
}; };

}

any = :function(x) { return true; };
bool = any;
object = any;
elementMakerB = any;
elementMaker = any;

anyFunction = :function(x) {
    return typeof x  == "function";
};

anyArray = :function(x) {
  return x instanceof Array;
};


html = :isHtml;

htmlOrId = :function(x) {
  return isHtml(x) || document.getElementById(x) != null;
};


location = :function(x) {
  return x == undefined || x == "before" || x == "after" || x == "leftMost" ||
         x == "rightMost" || x == "over" || x == "beginning" || x == "end";
};

positiveInt = :function(x) { return x >= 0; };

string = :function(x) { return typeof(x) == "string"; };

int = :function(x) { return typeof(x) == "number"; };

request = :function(x) {
  return x == "get " || x == "rest" || x == "post" || x == "rawPost";
};

response = :function(x) {
  return x == "json" || x == "xml" || x == "plain";
};

instance Behavior {
  changes : -> EventStream,
  delay_b : Behavior -> Behavior,
  blind_b : Behavior -> Behavior,
  calm_b : Behavior -> Behavior,
  valueNow : -> any,
  switch_b : -> Behavior, // TODO: underspecified
  not_b : -> Behavior,
  // TODO: underspecified (this carries fn)
  lift_b : or(Behavior,anyFunction) any ... -> Behavior, 
  if_b : Behavior Behavior -> Behavior
};

instance EventStream {
  lift_e : anyFunction -> EventStream,
  switch_e : -> EventStream, // TODO: underspecified
  filter_e : anyFunction -> EventStream,
  if_e : EventStream EventStream -> EventStream,
  constant_e : any -> EventStream,
  collect_e : any anyFunction -> EventStream,
  not_e : -> EventStream,
  filterRepeats_e : -> EventStream,
  snapshot_e : Behavior -> EventStream,
  once_e : -> EventStream,
  skipFirst_e : EventStream -> EventStream,
  delay_e :  Behavior -> EventStream,
  blind_e :  Behavior -> EventStream,
  calm_e :  Behavior -> EventStream,
  hold : any -> Behavior
};


constant_b :: any -> Behavior;
delay_b :: Behavior or(Behavior,positiveInt) -> Behavior;
calm_b :: Behavior Behavior -> Behavior;
blind_b :: Behavior Behavior -> Behavior;
valueNow :: Behavior -> any;
switch_b :: Behavior -> Behavior;
and_b :: Behavior ... -> Behavior;
or_b :: Behavior ... -> Behavior;
not_b :: Behavior -> Behavior;
lift_b :: or(Behavior,anyFunction) Behavior ... -> Behavior;
cond_b :: [Behavior,Behavior] ... -> Behavior;
if_b :: Behavior Behavior Behavior -> Behavior;
timer_b :: Behavior -> Behavior;
insertDomB :: Behavior htmlOrId location -> any;
mouseTop_b :: html -> Behavior;
mouseLeft_b :: html -> Behavior;
mouse_b :: html -> Behavior;
extractValue_b :: htmlOrId -> Behavior;
extractValue_e :: htmlOrId -> EventStream;
// TODO: underspecified, behavior carries htmlOrId
extractEvent_e :: or(Behavior,htmlOrId) string -> EventStream;
clicks_e :: htmlOrId -> EventStream;
timer_e :: Behavior -> EventStream;
extractValueOnEvent_e :: EventStream htmlOrId -> EventStream;
extractId_b :: string -> Behavior;
insertDomE :: EventStream htmlOrId location -> any;
insertValueE :: EventStream htmlOrId string ... -> any;
insertValueB :: Behavior htmlOrId string ... -> any;
tagRec :: [ string, ... ] (EventStream ... -> Behavior)
       -> Behavior;
getWebServiceObject_e
  :: { url : string
     , request : request
     , response : response
     , fields : any
     , body : any // optional(string)
     , asynchronous : any // optional(bool)
     }
  -> EventStream;
evalForeignScriptVal_e :: EventStream // TODO: { url: any , globalArg: any }
                       -> EventStream;


one_e :: any -> EventStream;
zero_e :: -> EventStream;
lift_e ::  anyFunction EventStream -> EventStream;
merge_e :: EventStream ... -> EventStream;
switch_e :: EventStream -> EventStream;
filter_e :: EventStream anyFunction -> EventStream;
if_e :: EventStream EventStream -> EventStream;
constant_e :: EventStream any -> EventStream;
collect_e :: EventStream any anyFunction -> EventStream;
and_e :: EventStream ... -> EventStream;
or_e :: EventStream ... -> EventStream;
not_e :: EventStream -> EventStream;
filterRepeats_e :: EventStream -> EventStream;
receiver_e :: -> EventStream;
sendEvent :: any EventStream -> any;
snapshot_e :: EventStream Behavior -> EventStream;
once_e :: EventStream -> EventStream;
skipFirst_e :: EventStream -> EventStream;
delay_e :: Behavior -> EventStream;
blind_e :: Behavior -> EventStream;
calm_e :: Behavior -> EventStream;
hold :: EventStream any -> Behavior;
changes :: Behavior -> EventStream;

// also $$
getElementsByClass :: string any any -> [ html, ... ]; 
// optional(html) optional(string) -> [ html, ... ];
getObj :: htmlOrId -> html;
$ :: htmlOrId -> html;
readCookie :: string -> any; // optional(string);
swapDom :: htmlOrId htmlOrId -> any;
getURLParam :: string -> any; // optional(string);
cumulativeOffset :: html -> { left: int, top: int };

// Flapjax's map works over arbitrarily many arrays.
map :: anyFunction anyArray ... -> anyArray;

// Element constructors

A :: elementMaker;
B :: elementMaker;
BLOCKQUOTE :: elementMaker;
BR :: elementMaker;
BUTTON :: elementMaker;
CANVAS :: elementMaker;
DIV :: elementMaker;
FIELDSET :: elementMaker;
FORM :: elementMaker;
FONT :: elementMaker;
H1 :: elementMaker;
H2 :: elementMaker;
H3 :: elementMaker;
H4 :: elementMaker;
HR :: elementMaker;
IMG :: elementMaker;
IFRAME :: elementMaker;
INPUT :: elementMaker;
LABEL :: elementMaker;
LEGEND :: elementMaker;
LI :: elementMaker;
OL :: elementMaker;
OPTGROUP :: elementMaker;
OPTION :: elementMaker;
P :: elementMaker;
PRE :: elementMaker;
SELECT :: elementMaker;
SPAN :: elementMaker;
STRONG :: elementMaker;
TABLE :: elementMaker;
TBODY :: elementMaker;
TD :: elementMaker;
TEXTAREA :: elementMaker;
TFOOT :: elementMaker;
TH :: elementMaker;
THEAD :: elementMaker;
TR :: elementMaker;
TT :: elementMaker;
UL ::elementMaker;
TEXT :: elementMaker;

AB :: elementMakerB;
BB :: elementMakerB;
BLOCKQUOTEB :: elementMakerB;
BRB :: elementMakerB;
BUTTONB :: elementMakerB;
CANVASB :: elementMakerB;
DIVB :: elementMakerB;
FIELDSETB :: elementMakerB;
FORMB :: elementMakerB;
FONTB :: elementMakerB;
H1B :: elementMakerB;
H2B :: elementMakerB;
H3B :: elementMakerB;
H4B :: elementMakerB;
HRB :: elementMakerB;
IMGB :: elementMakerB;
IFRAMEB :: elementMakerB;
INPUTB :: elementMakerB;
LABELB :: elementMakerB;
LEGENDB :: elementMakerB;
LIB :: elementMakerB;
OLB :: elementMakerB;
OPTGROUPB :: elementMakerB;
OPTIONB :: elementMakerB;
PB :: elementMakerB;
PREB :: elementMakerB;
SELECTB :: elementMakerB;
SPANB :: elementMakerB;
STRONGB :: elementMakerB;
TABLEB :: elementMakerB;
TBODYB :: elementMakerB;
TDB :: elementMakerB;
TEXTAREAB :: elementMakerB;
TFOOTB :: elementMakerB;
THB :: elementMakerB;
THEADB :: elementMakerB;
TRB :: elementMakerB;
TTB :: elementMakerB;
ULB ::elementMakerB;
TEXTB :: elementMakerB;
