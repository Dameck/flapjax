// TODO: mutually recursive named contracts (all vars on top)
// variable-arity contracts
// method contracts that place conditions on this (for switch_e)
// EventStream-of (how generically???)
// arbitrary-length array contracts [ ctc, ... ]
// Behavior contract is either a higher-order behavior or a flat (constant) 
// value
// remove cond_e it is stupid
// DOM contract list
// dictionary contract (on $O)
// Stop exporting generic functions
{
  
function html(x) {
  return x instanceof window.HTMLElement || x instanceof window.Text;
};

}

any = :function(x) { return true; };
bool = any;
object = any;

anyFunction = :function(x) {
    return typeof x  == "function";
};


html = :html;

htmlOrId = :function(x) {
  return html(x) || document.getElementById(x) != null;
};


location = :function(x) {
  return x == undefined || x == "before" || x == "after" || x == "leftMost" ||
         x == "rightMost" || x == "over" || x = "beginning" || x == "end";
};

positiveInt = :function(x) { return x >= 0; };

string = :function(x) { return typeof(x) == "string"; };

int = :function(x) { return typeof(x) == "number"; };

request = :function(x) {
  return x == "get " || x == "rest" || x == "post" || x == "rawPost";
};

response = :function(x) {
  return x == "json" || x == "xml" || x == "plain";
};

Behavior = {
  changes : -> EventStream,
  delay_b : BehaviorOf(positiveInt) -> Behavior,
  blind_b : BehaviorOf(positiveInt) -> Behavior,
  calm_b : BehaviorOf(positiveInt) -> Behavior,
  valueNow : -> any,
  switch_b : -> Behavior, // TODO: underspecified
  not_b : Behavior,
  lift_b : Behavior ... -> Behavior // TODO: underspecified (this carries fn)
  if_b : Behavior Behavior -> : Behavior
};

constant_b :: any -> Behavior;
delay_b :: Behavior BehaviorOf(positiveInt) -> Behavior;
calm_b :: Behavior BehaviorOf(positiveInt) -> Behavior;
blind_b :: Behavior BehaviorOf(positiveInt) -> Behavior;
valueNow :: Behavior -> any;
switch_b :: BehaviorOf(Behavior) -> Behavior;
and_b :: Behavior ... -> Behavior;
or_b :: Behavior ... -> Behavior;
not_b :: Behavior -> Behavior;
lift_b :: BehaviorOf(anyFunction) Behavior ... -> Behavior;
cond_b :: [Behavior,Behavior] ... -> Behavior;
if_b :: Behavior Behavior Behavior -> Behavior;
timer_b :: BehaviorOf(positiveInt) -> BehaviorOf(positiveInt);
insertDomB :: BehaviorOf(html) htmlOrId location -> any;
mouseTop_b :: html -> BehaviorOf(int);
mouseLeft_b :: html -> BehaviorOf(int);
mouse_b :: html -> BehaviorOf({ x : int, y : int });
extractValue_b :: htmlOrId -> Behavior;
extractValue_e :: htmlOrId -> EventStream;
extractEvent_e :: htmlOrId string -> EventStream;
clicks_e :: htmlOrId -> EventStream;
timer_e :: BehaviorOf(positiveInt) -> EventStreamOf(positiveInt);
extractValueOnEvent_e :: EventStream htmlOrId -> EventStream;
extractId_b :: string BehaviorOf(html) -> BehaviorOf(html);
insertDomE :: EventStreamOf(html) htmlOrId location -> any;
insertValueE :: EventStream htmlOrId string ... -> any;
insertValueB :: Behavior htmlOrId string ... -> any;
tagRec :: [ string, ... ] (EventStream ... -> BehaviorOf(html)) 
       -> BehaviorOf(html);
getWebServiceObject_e
  :: { url : string
     , request : request
     , response : response
     , fields : any
     , body : any // optional(string)
     , asynchronous : any // optional(bool)
     }
  -> EventStream;
evalForeignScriptVal_e :: { url: string, globalArg: string }
                       -> EventStream;

EventStream = {
  lift_e : anyFunction -> EventStream,
  switch_e : -> EventStream, // TODO: underspecified
  filter_e : anyFunction -> EventStream,
  if_e : EventStream EventStream -> EventStream,
  constant_e : any -> EventStream,
  collect_e : any anyFunction -> EventStream,
  not_e : -> EventStream,
  filterRepeats_e : -> EventStream,
  sendEvent : any -> any,
  snapshot_e : Behavior -> EventStream,
  once_e : EventStream,
  skipFirst_e : EventStream -> EventStream,
  delay_e :  Behavior -> EventStream,
  blind_e :  Behavior -> EventStream,
  calm_e :  Behavior -> EventStream,
  hold : any -> Behavior
};


one_e :: any -> EventStream;
zero_e :: EventStream;
lift_e ::  anyFunction EventStream -> EventStream;
merge_e :: EventStream ... -> EventStream;
switch_e :: EventStreamOf(EventStream) -> EventStream;
filter_e :: EventStream anyFunction -> EventStream;
if_e :: EventStream EventStream -> EventStream;
constant_e :: EventStream any -> EventStream;
collect_e :: EventStream any anyFunction -> EventStream;
and_e :: EventStream ... -> EventStream;
or_e :: EventStream ... -> EventStream;
not_e :: EventStream -> EventStream;
filterRepeats_e :: EventStream -> EventStream;
receiver_e :: -> EventStream;
sendEvent :: any EventStream -> any;
snapshot_e :: EventStream Behavior -> EventStream;
once_e :: EventStream -> EventStream;
skipFirst_e :: EventStream -> EventStream;
delay_e :: Behavior -> EventStream;
blind_e :: Behavior -> EventStream;
calm_e :: Behavior -> EventStream;
hold :: EventStream any -> Behavior;
changes :: Behavior -> EventStream;

// also $$
getElementsByClass :: string optional(html) optional(string) -> [ html, ... ];
// also $A
getObjsA :: htmlOrId ... -> [ html, ... ];
// also $O
getObjs :: string ... -> object; // TODO: underspecified (dictionary contract)
// also $
getObj :: htmlOrId -> html;
readCookie :: string -> optional(string);
swapDom :: htmlOrId htmlOrId -> any;
getURLParam :: string -> optional(string);
cumulativeOffset :: html -> { left: int, top: int };

