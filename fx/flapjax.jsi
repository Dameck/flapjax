// Behavior contract is either a higher-order behavior or a flat (constant) 
// value
// remove condE it is stupid
// DOM contract list
// dictionary contract (on $O)

{
  
function isHtml(x) {
  return x instanceof window.HTMLElement || x instanceof window.Text ||
    x instanceof window.Document;
};

// contract constructor.  Assumes ctc1 if the value satisfies ctc1.flat.
// Otherwise, assumes ctc2.  The server and client projections perform this
// test independently, so it's possible for a malformed inner contract to
// make one projection assume ctc1 and the other assume ctc2.
var or = function(name) { return function(ctc1, ctc2) {
  return {
    flat: function(val) {
      return ctc1.flat(val) || ctc2.flat(val);
    },
    server: function(s,loc) { return function(val) {
      if (ctc1.flat(val)) {
        return ctc1.server(s,loc)(val);
      }
      else {
        return ctc2.server(s,loc)(val);
      }
    } },
    client: function(s,loc) { return function(val) {
      if (ctc1.flat(val)) {
        return ctc1.client(s,loc)(val);
      }
      else {
        return ctc2.client(s,loc)(val);
      }
    } }
  }; 
}; };

var optional = function(name) { return function(valueContract) {
  return {
    flat: function(val) {
      return val === undefined || valueContract.flat(val);
    },
    server: function(s,loc) { return function(val) {
      if (val === undefined) { return val; }
      else { return valueContract.server(s,loc)(val); }
    }; },
    client: function(s,loc) { return function(val) {
      if (val === undefined) { return val; }
      else { return valueContract.client(s,loc)(val); }
    }; }
  };
}; };

var EventStreamOf = function(name) { return function(eventValueContract) {
  return { 
    flat: function(val) {
      return val instanceof impl.EventStream;
    },
    server: function(s,loc) { return function(val) {
      if (val instanceof impl.EventStream) {
        return val.liftE(function(e) {
           return eventValueContract.server(s,loc)(e);
        });
      }
      else {
        contracts.blame(s,name,val,"not an EventStream",loc);
      }
    }; },
    client: function(s,loc) { return function(val) {
      if (val instanceof impl.EventStream) {
        return val.liftE(function(e) {
           return eventValueContract.client(s,loc)(e);
        });
      }
      else {
        return val;
      }
    }; }
  };
}; };

// Many Flapjax functions treat non-behavior values as constant behaviors.
// However, BehaviorOf only accepts instances of Behavior.
var BehaviorOf = function(name) { return function(valueContract) {
  return { 
    flat: function(val) {
      return val instanceof impl.Behavior;
    },
    server: function(s,loc) { return function(val) {
      if (val instanceof impl.Behavior) {
        return val.liftB(function(e) {
           return valueContract.server(s,loc)(e);
        });
      }
      else {
        contracts.blame(s,name,val,"not a Behavior",loc);
      }
    }; },
    client: function(s,loc) { return function(val) {
      if (val instanceof impl.Behavior) {
        return val.liftB(function(e) {
           return valueContract.client(s,loc)(e);
        });
      }
      else {
        return val;
      }
    }; }
  };
}; };

}


any = :function(x) { return true; };
staticAttributes = any;

anyBehavior = any; // or(any,Behavior) = any
bool = any;
object = any;
// The first argument may be an attribute object (any) or an html element.
elementMaker = any or(html,string) ... -> html;
elementMakerB = any or(string,or(html,BehaviorOf(or(string,html)))) ... 
                -> BehaviorOf(html);

anyFunction = :function(x) {
    return typeof x  == "function";
};

anyArray = :function(x) {
  return x instanceof Array;
};


html = :isHtml;

htmlOrId = :function(x) {
  return isHtml(x) || document.getElementById(x) != null;
};

inputName = :function(name) {
  var inputs = document.getElementsByTagName("input");
  for (var i = 0; i < inputs.length; i++) {
    if (inputs[i].getAttribute('name') == name) { return true; }
  }
  return false;
};


location = :function(x) {
  return x == undefined || x == "before" || x == "after" || x == "leftMost" ||
         x == "rightMost" || x == "over" || x == "beginning" || x == "end";
};

positiveInt = :function(x) { return x >= 0; };

string = :function(x) { return typeof(x) == "string"; };

int = :function(x) { return typeof(x) == "number"; };

request = :function(x) {
  return x == "get " || x == "rest" || x == "post" || x == "rawPost";
};

response = :function(x) {
  return x == "json" || x == "xml" || x == "plain";
};

instance Behavior {
  changes : -> EventStream,
  delayB : or(positiveInt,BehaviorOf(positiveInt)) -> Behavior,
  blindB : or(positiveInt,BehaviorOf(positiveInt)) -> Behavior,
  calmB : or(positiveInt,BehaviorOf(positiveInt)) -> Behavior,
  valueNow : -> any,
  switchB : -> Behavior, // TODO: underspecified
  notB : -> Behavior,
  // the rest arguments may be 
  liftB : or(BehaviorOf(anyFunction),anyFunction) anyBehavior ... -> Behavior, 
  ifB : Behavior Behavior -> Behavior
};

instance EventStream {
  liftE : anyFunction -> EventStream,
  // TODO: a better contract should restrict this
  switchE : -> EventStream,
  filterE : anyFunction -> EventStream,
  ifE : EventStream EventStream -> EventStream,
  constantE : any -> EventStream,
  collectE : any anyFunction -> EventStream,
  notE : -> EventStream,
  filterRepeatsE : -> EventStream,
  snapshotE : Behavior -> EventStream,
  onceE : -> EventStream,
  skipFirstE : EventStream -> EventStream,
  delayE :  or(positiveInt,BehaviorOf(positiveInt)) -> EventStream,
  blindE :  or(positiveInt,BehaviorOf(positiveInt)) -> EventStream,
  calmE :  or(positiveInt,BehaviorOf(positiveInt)) -> EventStream,
  startsWith : any -> Behavior
};

notEventStream = :function(x) { return !(x instanceof impl.EventStream); };

constantB :: any -> Behavior;
delayB :: Behavior or(BehaviorOf(positiveInt),positiveInt) -> Behavior;
calmB :: Behavior or(BehaviorOf(positiveInt),positiveInt) -> Behavior;
blindB :: Behavior or(BehaviorOf(positiveInt),positiveInt) -> Behavior;
valueNow :: Behavior -> any;
switchB :: BehaviorOf(Behavior) -> Behavior;
andB :: Behavior ... -> Behavior;
orB :: Behavior ... -> Behavior;
notB :: Behavior -> Behavior;
liftB :: or(BehaviorOf(anyFunction),anyFunction) Behavior ... -> Behavior;
condB :: [Behavior,Behavior] ... -> Behavior;
ifB :: Behavior Behavior Behavior -> Behavior;
timerB :: or(positiveInt,BehaviorOf(positiveInt)) -> Behavior;
// just about anything can be printed to the DOM
insertDomB :: notEventStream htmlOrId location -> any;
mouseTopB :: html -> Behavior;
mouseLeftB :: html -> Behavior;
mouseB :: html -> Behavior;
extractValueB :: or(htmlOrId,inputName) -> Behavior;
extractValueE :: or(htmlOrId,inputName) -> EventStream;
// TODO: underspecified, behavior carries htmlOrId
extractEventE :: or(BehaviorOf(htmlOrId),htmlOrId) string -> EventStream;
clicksE :: htmlOrId -> EventStream;
timerE :: Behavior -> EventStream;
extractValueOnEventE :: EventStream htmlOrId -> EventStream;
extractIdB :: string -> Behavior;
insertDomE :: EventStream htmlOrId location -> any;
insertValueE :: EventStream htmlOrId string ... -> any;
insertValueB :: Behavior htmlOrId string ... -> any;
tagRec :: [ string, ... ] (EventStream ... -> Behavior)
       -> Behavior;
getWebServiceObjectE
  :: { url : string
     , request : request
     , response : response
     , fields : any
     , body : optional(string)
     , asynchronous : optional(bool)
     }
  -> EventStream;
getForeignWebServiceObjectE
  :: { url : string
     , request : request
     , response : response
     , fields : any
     , body : optional(string)
     , asynchronous : optional(bool)
     }
  -> EventStream;
evalForeignScriptValE :: EventStreamOf({ url: string, globalArg: string })
                       -> EventStream;


oneE :: any -> EventStream;
zeroE :: -> EventStream;
liftE ::  anyFunction EventStream -> EventStream;
mergeE :: EventStream ... -> EventStream;
switchE :: EventStreamOf(EventStream) -> EventStream;
filterE :: EventStream anyFunction -> EventStream;
ifE :: EventStream EventStream -> EventStream;
constantE :: EventStream any -> EventStream;
collectE :: EventStream any anyFunction -> EventStream;
andE :: EventStream ... -> EventStream;
orE :: EventStream ... -> EventStream;
notE :: EventStream -> EventStream;
filterRepeatsE :: EventStream -> EventStream;
receiverE :: -> EventStream;
sendEvent :: any EventStream -> any;
snapshotE :: EventStream Behavior -> EventStream;
onceE :: EventStream -> EventStream;
skipFirstE :: EventStream -> EventStream;
delayE :: Behavior -> EventStream;
blindE :: Behavior -> EventStream;
calmE :: Behavior -> EventStream;
startsWith :: EventStream any -> Behavior;
changes :: Behavior -> EventStream;

// also $$
getElementsByClass :: string optional(html) optional(string) -> [ html, ... ];
getObj :: htmlOrId -> html;
$ :: htmlOrId -> html;
readCookie :: string -> optional(string); // may return undefined
swapDom :: htmlOrId htmlOrId -> any;
getURLParam :: string -> optional(string); // may return undefined
cumulativeOffset :: html -> { left: int, top: int };

// Flapjax's map works over arbitrarily many arrays.
map :: anyFunction anyArray ... -> anyArray;

// Element constructors

A :: elementMakerB;
B :: elementMakerB;
BLOCKQUOTE :: elementMakerB;
BR :: elementMakerB;
BUTTON :: elementMakerB;
CANVAS :: elementMakerB;
DIV :: elementMakerB;
FIELDSET :: elementMakerB;
FORM :: elementMakerB;
FONT :: elementMakerB;
H1 :: elementMakerB;
H2 :: elementMakerB;
H3 :: elementMakerB;
H4 :: elementMakerB;
HR :: elementMakerB;
IMG :: elementMakerB;
IFRAME :: elementMakerB;
INPUT :: elementMakerB;
LABEL :: elementMakerB;
LEGEND :: elementMakerB;
LI :: elementMakerB;
OL :: elementMakerB;
OPTGROUP :: elementMakerB;
OPTION :: elementMakerB;
P :: elementMakerB;
PRE :: elementMakerB;
SELECT :: elementMakerB;
SPAN :: elementMakerB;
STRONG :: elementMakerB;
TABLE :: elementMakerB;
TBODY :: elementMakerB;
TD :: elementMakerB;
TEXTAREA :: elementMakerB;
TFOOT :: elementMakerB;
TH :: elementMakerB;
THEAD :: elementMakerB;
TR :: elementMakerB;
TT :: elementMakerB;
UL ::elementMakerB;
TEXT :: elementMakerB;

A_ :: elementMaker;
B_ :: elementMaker;
BLOCKQUOTE_ :: elementMaker;
BR_ :: elementMaker;
BUTTON_ :: elementMaker;
CANVAS_ :: elementMaker;
DIV_ :: elementMaker;
FIELDSET_ :: elementMaker;
FORM_ :: elementMaker;
FONT_ :: elementMaker;
H1_ :: elementMaker;
H2_ :: elementMaker;
H3_ :: elementMaker;
H4_ :: elementMaker;
HR_ :: elementMaker;
IMG_ :: elementMaker;
IFRAME_ :: elementMaker;
INPUT_ :: elementMaker;
LABEL_ :: elementMaker;
LEGEND_ :: elementMaker;
LI_ :: elementMaker;
OL_ :: elementMaker;
OPTGROUP_ :: elementMaker;
OPTION_ :: elementMaker;
P_ :: elementMaker;
PRE_ :: elementMaker;
SELECT_ :: elementMaker;
SPAN_ :: elementMaker;
STRONG_ :: elementMaker;
TABLE_ :: elementMaker;
TBODY_ :: elementMaker;
TD_ :: elementMaker;
TEXTAREA_ :: elementMaker;
TFOOT_ :: elementMaker;
TH_ :: elementMaker;
THEAD_ :: elementMaker;
TR_ :: elementMaker;
TT_ :: elementMaker;
UL_ ::elementMaker;
TEXT_ :: elementMaker;

fold :: any;
map :: any;
filter :: any;
member :: any;
slice :: any;
forEach :: any;

compilerLift :: any;
compilerCall :: any;
compilerIf :: any;
compilerUnbehavior :: any;
